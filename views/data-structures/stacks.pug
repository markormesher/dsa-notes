extends ../_shared/page-layout

block page-body

	h1 Stacks

	ul
		li: a(href = '#implementation') Implementation
		li: a(href = '#efficiency') Efficiency
		li: a(href = '#example-basic-usage') Example: Basic Usage

	p A stack is a collection that allows elements to be retrieved in a #[strong Last In, First Out (LIFO)] order. The elements that were most recently added form the #[strong &quot;top&quot;] of the stack; the elements added least recently form the #[strong &quot;bottom&quot;] of the stack.

	p Stacks have two primary operations: #[code push(e)] to add the element #[code e] to the collection, and #[code pop()] to return the element that was most recently added to the stack that has not yet been removed. An additional #[code peek()] operation may return the top element without removing it from the collection.

	h2#implementation Implementation

	p Stacks are most commonly implemented on top of an #[a(href = '/data-structures/arrays') array] or #[a(href = '/data-structures/linked-lists') linked list].

	div.row
		div.col-md-6
			h3 Array Implementation, Pseudocode

			pre: code.
				class Stack {
					topIndex = 0
					elements = [];

					push(e) {
						elements[topIndex] = e
						++topIndex
					}

					pop() {
						if topIndex == 0 throw error

						--topIndex
						temp = elements[topIndex]
						deallocate elements[topIndex]
						return temp
					}

					peek() {
						if topIndex == 0 throw error

						return elements[topIndex - 1]
					}

					size() {
						return topIndex
					}
				}

		div.col-md-6
			h3 Linked List Implementation, Pseudocode

			pre: code.
				class Stack {
					LinkedList elements;

					push(e) {
						elements.insertAtHead(e)
					}

					pop() {
						if elements.isEmpty() throw error

						return elements.removeHead()
					}

					peek() {
						return elements.getHead()
					}

					size() {
						return elements.size
					}
				}

	h2#efficiency Efficiency

	div.row
		div.col-md-6
			p Both implementations above are capable of providing #[code O(1)] performance for push and pop operations.

			p Unless the stack's maximum size is known and fixed at creation, a #[a(href = '/data-structures/dynamic-arrays') dynamic array] must be used for an array-based implementation (they still offer amortised #[code O(1)] performance). In this case a trade-off exists: #[a(href = '/data-structures/linked-lists') linked lists] do not require contiguous memory but they do have a &quot;wasted&quot; memory overhead for pointers; #[a(href = '/data-structures/dynamic-arrays') dynamic arrays] require contiguous memory, but they make better use of it.

		div.col-md-6
			table.table
				tr
					td
					th w/ Arrays
					th w/ Linked Lists
				tr
					th Push
					td.success.text-mono O(1)
					td.success.text-mono O(1)
				tr
					th Pop
					td.success.text-mono O(1)
					td.success.text-mono O(1)
				tr
					th Peek
					td.success.text-mono O(1)
					td.success.text-mono O(1)

	h2#example-basic-usage Example: Basic Usage

	div.row
		div.col-md-6
			h3 Java

			pre: code.java.
				Stack&lt;Integer&gt; intStack = new Stack&lt;&gt;();

				intStack.push(4);
				intStack.push(15);
				intStack.push(37);

				// pop: returns and removes the top element
				System.out.println(intStack.pop()); // 37
				System.out.println(intStack.pop()); // 15

				System.out.println(intStack.size()); // 1

				// peek: returns, but doesn't remove the top element
				System.out.println(intStack.peek()); // 4
				System.out.println(intStack.isEmpty()); // false

				System.out.println(intStack.pop()); // 4
				System.out.println(intStack.isEmpty()); // true

		div.col-md-6
			h3 C++

			pre: code.cpp.
				stack&lt;int&gt; intStack;

				intStack.push(4);
				intStack.push(15);
				intStack.push(37);

				// top: returns, but doesn't remove the top element
				cout << intStack.top(); // 37
				cout << intStack.top(); // 37

				// pop: removes the top element, but doesn't return it
				intStack.pop(); // stack now has 2 elements

				cout << intStack.top(); // 15
				intStack.pop(); // stack now has 1 element

				cout << intStack.top(); // 4
				cout << intStack.empty(); // false

				intStack.pop();
				cout << intStack.empty(); // true